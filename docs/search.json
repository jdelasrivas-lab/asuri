[{"path":"/articles/asuri.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"present new algorithm called ASURI provides integrated set functions analyse disease SURVIVAL obtain patient RISK predictions based gene activity signatures. Specifically, algorithm designed : (1) Analyse ability given gene mark disease prognosis survival based gene expression gene-related activity signal; (2) Discover gene markers identifying significant association gene expression (gene-related signal) clinical variable phenotypic trait; (3) Constructing robust patient risk predictors based selected gene signatures using univariate multivariate approaches; (4) Predicting risk new query patients based gene expression profile classifying patients risk group (high/intermediate/low); (5) Estimating survival curve new query patients. accordance 5 utilities package described , ASURI built five R functions specific uses (Figure @ref(fig:diagramaCrop)): (1) geneSurv(), implements robust method evaluate ability given gene mark survival based expression level. based bootstrapped version Kaplan-Meier estimator long-rank statistics provided (Therneau 2021). function helps overcome instability irreproducibility tools developed purpose (Aguirre-Gamboa et al. 2013). (2) genePheno(), implements robust method select subset genes whose expression correlated clinical variable phenotypic parameter. function based Elastic Net algorithm proposed (Friedman, Hastie, Tibshirani 2010; Simon et al. 2011), removes features -relevant prediction clinical variable. improve stability reproducibility list genes associated phenotype, method implements bootstrap strategy. function provides several metrics useful evaluate stability relevance gene. function particularly useful clinicians want discover survival biomarkers interact clinical variables parameters relevant patient treatment. Workflow diagram package ASURI showing decision-making lines five main functions. Next function, (3) patientRisk(), accurately predicts patient risk given set informative genes, provided input list selected genes. function based multivariate UNICOX model proposed (R. Tibshirani 2009). function provides output list selected genes ranked according impact patient risk along relevance index. also provides risk prediction one patients included training considering gene signature obtained optimal stratification two three risk groups (.e., poor, intermediate good prognosis). (4) predict.patientRisk(), predicts risk new, novel patients based model gene signature produced patientRisk() function training set. function also classifies patients two three risk groups. (5) predSurvCurve(), estimates survival curve given query patient using patient’s gene expression profile. 5 functions included ASURI also provide graphical output plots help visualize analyze survival patient risk; , indicated, designed work one genes (.e., features), , analyze univariate multivariate gene signatures.","code":""},{"path":"/articles/asuri.html","id":"package-download-and-installation--package-dependencies-","dir":"Articles","previous_headings":"","what":"Package download and installation. Package dependencies.","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"ASURI package can installed directly Bioconductor typing following commands R: (!requireNamespace(“BiocManager”, quietly = TRUE)) { install.packages(“BiocManager”) } BiocManager::install(“ASURI”) can installed also local directory downloaded previously package. install.packages(“/path//ASURI.tar.gz”, dependencies = TRUE) library(ASURI) problem dependencies reported installation, users first download missing R packages directly CRAN R repository Bioconductor repository, repeat previous instructions install ASURI R package. Windows based OS, Rtools might need installed. package dependencies ASURI following, CRAN: ‘ggplot2’, ‘glmnet’, ‘Rdpack’, ‘ROCR’, ‘scales’; Bioconductor: ‘Biobase’, ‘siggenes’, ‘survcomp’. ASURI package also contains experimental dataset illustrate performance various functions methods implemented .","code":""},{"path":"/articles/asuri.html","id":"dataset-description-and-download-","dir":"Articles","previous_headings":"","what":"Dataset description and download.","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"dataset included ASURI study case intended facilitate use package. dataset obtained several GSE series GEO database corresponding breast cancer (BRCC) samples, expression survival time reported (Bueno-Fortes et al. 2023). sample corresponds genome-wide expression profiles BRCC primary tumor samples hybridized transcriptomic platform: Affymetrix HGU133 Plus2.0; high-density microarray expression platform containing 594,000 oligo-nucleotide probes (organized probe-sets) mapped ENSEMBL genes using hgu133plus2hsensgcdf CDF package, obtained BRAINARRAY. expression signal samples normalized using fRMA (McCall, Bolstad, Irizarry 2010) RMA (Gautier et al. 2004) Combat (Kupfer et al. 2012), described (Bueno-Fortes et al. 2023). Clinical variables information tumors collected included phenodata object. specifically, information expression level 3 key BRCC biomarkers (.e. ER / ESR1, PR / PGR, HER2 / ERBB2 protein-coding genes) included phenodata available. dataset downloaded two objects created: mExprs, normalized gene expression data matrix; mPheno includes information sample (.e. clinical physio-pathological data phenotypic data).","code":"data(mExprs) # To visualize the dimensions of the ExpressionSet object dim(mExprs) data(mPheno) # To visualize the dimensions of the phenotypic information # object dim(mPheno)"},{"path":"/articles/asuri.html","id":"platforms-supported-by-the-library-and-preprocessing-","dir":"Articles","previous_headings":"","what":"Platforms supported by the library and preprocessing.","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"library supports expression data matrices coming high-density microarrays (example data set described ), well expression data matrices coming RNA-seq platforms. However, can applied omic technology provides gene-related activity signal. transcriptomic / gene expression data, recommended transform gene signal using log2log_2 function standardize expression values, example calculating z-score. microarray data, recommended perform robust normalization raw signal running COX regression methods. addition, microarray datasets, gene expression signals calculated using RMA method (Gautier et al. 2004; McCall, Bolstad, Irizarry 2010) normalizeBetweenArrays method (Ritchie et al. 2015) (work well within ASURI package). RNA-seq datasets, data matrix counts per gene can used, recommend applying normalization method Voom method, considered (Scarfo et al. 2016).","code":""},{"path":"/articles/asuri.html","id":"survival-and-risk-assessment-case-study-on-breast-cancer-","dir":"Articles","previous_headings":"","what":"Survival and risk assessment (case study on Breast Cancer).","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"section, present explain use ASURI library, including five main functions described , applying package example breast cancer dataset (contains 200 samples 20,049 genes). different parts main section show different analyses can performed package.","code":""},{"path":"/articles/asuri.html","id":"analysis-of-individual-genes-as-survival-markers-genesurv","dir":"Articles","previous_headings":"Survival and risk assessment (case study on Breast Cancer).","what":"Analysis of individual genes as survival markers: geneSurv()","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"first goal ASURI algorithm identify human genes measured biological samples patients (e.g., measured tumor samples cancer patients) associated survival individuals (.e., prognosis). , algorithm examines expression (activity) query genes cohort samples patients disease, divides cohort samples high expression query gene samples low expression query gene. way, algorithm splits cohort two groups runs Kaplan-Meier (K-M) analysis two groups samples, determining whether K-M show significant difference based log-rank statistic. implemented geneSurv() function (Bueno-Fortes et al. 2023). statistic evaluates separability survival curves groups obtained gene expression (gene activity) threshold, : samples high expression versus samples low expression query gene. naive approach introduced tools, (Aguirre-Gamboa et al. 2013), estimates two groups samples just splitting cohort using mean median gene activity, trying obtain best p-value log-rank statistic KM two groups. strategy often yields meaningless solutions, giving rise highly unbalanced groups. overcome problems, geneSurv() function implements original method uses bootstrapping compute optimal threshold focuses split central 60% samples, avoiding unbalanced groups. described , improve stability reproducibility survival analysis available R packages (Kassambara et al. 2024), bootstrap strategy implemented ASURI. membership probability estimated classification patient (sample) one two risk groups (Figure @ref(fig:pclassesr1)). membership probabilities allow us robustly reclassify patients around gene expression threshold (Figure @ref(fig:boxesr1)). approach univariate take account interactions correlations genes (.e., considers feature gene independent). patients assigned two groups bootstrap strategy, function plots robust K-M curves confidence intervals (Figure @ref(fig:kmesr1)). example use, let’s now analyse using geneSurv() function well known gene survival marker dataset breast cancer: Estrogen Receptor (ER+, ESR1). input parameters function following: geneExpr Vector normalized gene expression sample. names(genExpr) contains sample names. time Numeric vector containing survival time sample years, including sample name names(time). status Numeric vector status (censored 0 censored 1) sample, names(status) include sample names. geneName character string name gene analyzed. boxplot logical value indicating whether generate boxplot gene expression survival group (default = TRUE). iter number iterations (bootstrap resampling) calculating optimal group cutoffs (default = 100). type Specifies whether two Kaplan-Meier curves computed using gene expression groups (default “exprs”), using risk groups (“risk”) samples already classified risk level used directly divide samples two groups. cut_time numeric value specifying cutoff time (years) survival analysis. events beyond time treated censored (default = 10 years).  function returns different outputs, .e., list values plots different depending specified type mode run. Run function geneSurv() type = \"exprs\": geneName: character string name gene analyzed. patientExpr: expression level query gene sample (.e., patient). patientClass: Vector group classification according gene expression level: 2 = high expression (HighExpr) 1 = low expression level (LowExpr). patientClassProbality: Vector membership probabilities classification. wilcox.pvalue: p-value Wilcoxon test comparing two expression groups. plot_values: list containing Kaplan-Meier curve results, log-rank test p-value, hazard ratio. Also three plots provided: Plot probability (0 1) samples belong one two groups classes obtained based expression level query gene (low expression high expression) (Figure @ref(fig:pclassesr1)). Boxplots showing expression distributions samples divided two defined groups (LowExpr versus HighExpr). plot includes p.value Wilcoxon test comparing two expression groups (Figure @ref(fig:boxesr1)). Kaplan-Meier plot showing curves calculated based survival two groups samples generated (.e., samples high expression query gene, red, samples low expression query gene, green). plot includes p.value log-rank statistical test obtained comparing K-M survival profile two groups (Figure @ref(fig:kmesr1)). type = \"risk\": geneName: character string name gene analyzed. patientExpr: expression level query gene sample (.e., patient). risk_score_predicted: numeric vector predicted calculated risk score (%, relative numbers) patient. plot_values: list containing Kaplan-Meier curve results, log-rank test p-value, hazard ratio. Also plot provided: Kaplan-Meier plot showing curves calculated based survival two groups samples generated (high risk low risk). plot includes p.value log-rank statistical test obtained comparing K-M survival profile two groups (Figure @ref(fig:kmrisk)). Patient Class Probability low exprs (89) high exprs (111) groups). Figure @ref(fig:pclassesr1) shows plot probability samples assigned one expression groups: low expression green high expression red. samples example correspond tumors isolated 200 breast cancer patients. probability belonging group estimated bootstrapping. Patients membership probability greater 0.8 classified high degree confidence. classification uncertain (p < 0.8) patients around intermediate gene expression level. Boxplot: high expression vs low expression ESR1 gene. Figure @ref(fig:boxesr1) boxplots showing expression distribution samples divided two defined groups (LowExpr versus HighExpr). plot includes p.value Wilcoxon test comparing two expression groups. Notice small overlapping high low expression groups. due reassignment patients intermediate expression level accomplished bootstrap strategy. Kaplan Meier curves obtained assignment patients bootstrap high low survival using selected feature ESR1. Figure @ref(fig:kmesr1) shows two Kaplan-Meier curves confidence intervals obtained function geneSurv() gene ESR1. threshold gene expression level splits samples two groups estimated optimization log-rank test statistic. procedure repeated 100 times using bootstrap strategy improve classification intermediate risk patients. result shown Figure @ref(fig:kmesr1), p-value log-rank test (= 0.01695) Hazard Ratio (= 1.86: CI (0.31, 3.13) ) suggest gene ESR1 good survival marker breast cancer. Run function geneSurv() type = \"risk\":  Kaplan Meier curves obtained assignment patients bootstrap high low survival using estimated risk based feature BRCA1. Figure @ref(fig:kmrisk) shows two Kaplan-Meier curves confidence intervals obtained function geneSurv() gene BRCA1. Now two groups obtained estimating risk patient determining split threshold optimizing log-rank test statistic two curves. procedure repeated 100 times using bootstrap strategy improve classification intermediate risk patients.","code":""},{"path":"/articles/asuri.html","id":"discovery-of-genes-associated-with-phenotypic-factors-genepheno","dir":"Articles","previous_headings":"Survival and risk assessment (case study on Breast Cancer).","what":"Discovery of genes associated with phenotypic factors: genePheno()","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"suggested literature clinical features physiopathological parameters patient’s disease can associated specific biomolecular pathways genes can identified markers patient’s condition status. genePheno() function implements robust algorithm obtain list genes associated given clinical variable phenotypic factor (Bueno-Fortes et al. 2023) measured cohort patients. genes may provide alternative novel targets standard known disease markers. genePheno() function performs feature selection fitting predictor given set samples based Elastic Net algorithm (proposed (Friedman, Hastie, Tibshirani 2010; Simon et al. 2011)). method incorporates regularization term lies Lasso Ridge regression. Small coefficients reduced zero predictor can include relevant variables Lasso improve prediction accuracy, even though may slightly correlated. way, avoid extreme behavior Lasso, randomly selects one . Thus, Elastic Net algorithm helps improve stability reduce variance feature selection process (Robert Tibshirani 1996). optimal value regularization parameter determined automatically nested cross-validation strategy. loss function predictor AUC (Area ROC Curve), considers balance false positive false negative errors. improve reproducibility stability list candidate genes found (.e., selected features) found significantly correlated clinical variable, bootstrap strategy implemented. Training data resampled replacement ensemble gene lists obtained. stability metric based selection probability defined. Thus, genes low selection probability robustly filtered . final gene list obtained two metrics. first one evaluates stability second one degree correlation clinical variable. approach multivariate takes account additive interactions candidate genes well possible correlations. running genePheno(), number input features, .e. number tested genes, reduced (thousand) improve computational efficiency function. However, preprocessing step done carefully avoid removing relevant genes. ASURI package provides function prefilterSAM(), implements differential expression algorithm called SAM (proposed (Tusher, Tibshirani, Chu 2001; Li Tibshirani 2013)) obtain set significant genes selected. prefilterSAM() improves stability robustness SAM applying bootstrapping strategy. preliminary gene list, optimal lambda threshold calculated repeating process different FDR values selecting one minimizes p-value. final list contains genes present least 10% iterations. step can skipped already selected set informative genes. input parameters function following: mExprs: data matrix rows genes columns samples. Thus, entry expression value gene sample. groups_vector: binary vector indicating group sample assigned. FDRfilter: numeric value indicating FDR threshold selecting significant genes. default FDR = 0.05. iter: number iterations bootstrapping. Default 100. percentageFilter: numeric value indicating percentage iterations gene must appear considered significant. Default 80. output DE_list_genes function list genes obtained differential expression analysis ordered p-value (lowest highest p-value). following code illustrates use genePheno() function discover genes correlated Estrogen Receptor (ER+, ESR1) measured clinicians (pathologists) phenotypic variable breast cancer tumors (.e., discover genes correlated level ESR1 protein detected immunohistochemistry, IHC, BRCC tumors). input parameters following: mExpr: matrix normalized gene expression data. Rows correspond samples, columns correspond genes. rownames(mExpr) set sample names, colnames(mExpr) set gene names. Since selected subset differentially expressed genes, genePheno() function run genes. Therefore, mExpr generate new expression matrix:tmExprsDE, includes genes significant DE analysis. vectorGroups: Clinical phenotypic variable tested. must provided binary vector. particular study vectorGroups mPheno$ER.IHC. vectorSampleID: Vector containing sample names ordered expression matrix. iter: Number bootstrap iterations (default: 100). can changed function takes long run. numberOfFolds: Number folds implement nested cross-validation (default: 10). Table 1: List genes Stability. output function object following elements: genes: list genes ranked according degree association clinical phenotypic variable tested. listCoeff: list beta regression coefficients AUC score bootstrap iteration. stability: Gene selection probability (0 1) estimated bootstrap (number times discovered “n” iterations). betasMedian: Median beta coefficients B replicates. betasMean: Mean beta coefficients B replicates. betasTable: Output table genes ordered decreasing value stability, includes genes, stability, betasMedian betasMean. results obtained Table 1 show expression ESR1 gene strongly associated clinical marker ER (.e., detection IHC Estrogen Receptor active tumors). expected, result supports value developed method presented . addition, AGR3, SUSD3 CA12 genes recently found breast cancer literature relation ER marker (Barnett et al. 2008; Yu et al. 2015; Garczyk et al. 2015); also found method good ranking association ER (.e., present high stability). genes positively correlated, suggesting may play role function similar way clinical marker ER. Therefore, genes can proposed alternative molecular targets breast cancer, becoming excellent candidates investigate value diagnosis, prognosis, sensitivity endocrine therapies.","code":""},{"path":"/articles/asuri.html","id":"identification-of-gene-survival-markers-patient-risk-prediction-patientrisk","dir":"Articles","previous_headings":"Survival and risk assessment (case study on Breast Cancer).","what":"Identification of gene survival markers & patient risk prediction: patientRisk()","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"preliminary set candidate genes proposed, ASURI algorithm designed explore genes identify ones correlated survival risk, therefore adequate prognostic markers (.e., good gene survival markers). case study presented , using genePheno() function, algorithm explores data identify gene markers correlate presence ER+ clinical variable. However, general use patientRisk() function, algorithm evaluates whole set genes respect survival profiles builds multivariate risk predictor, identifying genes able accurately predict patient risk. analysis find significant correlation expression level genes survival patients performed function patientRisk() (Bueno-Fortes et al. 2023). function based Univariate Shrinkage COX Model (UNICOX) proposed (R. Tibshirani 2009). method shrinks irrelevant coefficients zero, taking account L1L_1 norm penalty term. Features penalized individually, allowing genes correlated risk retained given numerical strength. behavior differs Lasso models (Robert Tibshirani 1996), one representative gene randomly chosen group correlated genes. patientRisk() function estimates regularization parameter using double nested cross-validation provide robustness feature selection. cross-validation includes inner (first) loop estimate optimal regularization parameter outer (second) loop estimate risk. risk curve obtained, patientRisk() implements original method stratify patients two main risk groups. method similar one used (Figure @ref(fig:pclassesr1)), since orders patients risk computes p-values log-rank test possible split patients two groups corresponding survival. , calculates interval corresponding lower 10th percentile p-values. extreme values interval provide lower upper thresholds stratify patients low, intermediate high risk groups (see Figure @ref(fig:plot1risk)). optimal threshold dividing patients two groups (low/high) can obtained three methods: (1) first approach estimates threshold minimizing p-value log-rank statistic, .e. maximizing separability K-M curves high low risk groups. multiple local minima occur, may sample dependent unstable. (2) improve robustness second method implemented computes threshold median lower 10th percentile log-rank p-values. lower 10 percentile selects smallest values p-value distribution correspond intermediate risk patients border two groups. interval robust single minimum provides good experimental results wide variety problems tested. median threshold interval may change one iteration another distribution p-values patients intermediate risk may change due sample variation. Therefore, (3) bootstrapping strategy implemented intermediate risk patients, helps improve robustness threshold obtained provides probability membership risk group. following code illustrates apply patientRisk() function discover/identify significant gene survival markers accurately predict patient risk.  input parameters patientRisk() function following: mExpr numeric matrix gene expression data row represents gene column represents sample. time numeric vector representing survival time sample, names(time) defined sample names. status numeric vector representing event status (1 = event, 0 = censored) sample, names(status) defined sample names. group.vector numeric vector specifying predefined risk groups patients. optional. method string determines method considered stratified patients two risk groups according risk score lower 10th percentile p-values: (1) min.pval Defines risk groups based minimum p-value. (2) med.pval Defines risk groups based median p-value. approach can robust several local minima found. Finally, (3) class.probs Defines risk groups based classification probabilities model. provides also membership probability risk group. class.probs selected default. nboot integer specifying number bootstrap iterations risk score calculation. Default 50. patientRisk() function returns list containing following objects: cv_risk_score: Risk score prediction training set using double nested crossvalidated strategy. cv_normalized_risk: Normalized risk score interval (0, 100). table_genes_selected: Data frame following columns: () names genes selected COX regression; (ii) beta coefficients optimal multivariate COX regression fitted training set; (iii) Hazard Ratio gene; (iv) p-value univariate log-rank statistical test. Genes shown descending order HR index. table_genes_selected_extended: Table format table_genes_selected. search local minima within 5% range selected minimum performed. goal expanding list significant genes improve biological interpretability, since Lasso penalty drastically reduces number significant genes. model.optimalLambda: Object contains parameters optimal multivariate COX regression. groups: Vector classification patients two risk groups: HighRisk (2) LowRisk (1). riskThresholds: Thresholds allows stratify test patients three groups according predicted risk score: low, intermediate high risk. range.risk: Range unscaled risk score training set. listmodels: List models tested different values regularization parameter λ\\lambda. evaluation.models: Dataframe provides several metrics model evaluated. lambda regularization parameter multivariate COX regression adjusted; number_features gives number genes selected model; c.index se.c.index concordance index standard deviation risk prediction; p_value_c.index logrank_p_value give p-values concordance index log-rank statistics respectively. models shown ascending order p-values log-rank test, best one marked two asterisks. metrics estimated using double nested cross-validation strategy. betasplot: Dataset used create plot genes ranked according regression coefficients multivariate COX model (UNICOX). plot_values: list containing Kaplan-Meier fit results, logrank p-value, hazard ratio. membership_prob: method class.probs selected table two columns returned. first one probability classification low risk group second one membership probability high risk group. function patientRisk() generates 5 plots: Curve log-rank p-values possible splitting patients 2 risk groups. X axis represents patient number ranked low high risk. green line marks selected cutpoint, .e., point provides threshold stratifying patients 2 risk groups: low risk, blue; high risk, red. blue & red lines define thresholds classifying patients 3 risk groups: low, intermediate high. lines mark samples fall intermediate region, risk assignment precise samples may fluctuate position. Risk Score, 0 100, calculated patient, .e., 200 patient tumor samples included study, obtained multivariate UNICOX regression model. model includes features subset selected genes included geneList, tested find correlation risk. green blue & red lines provide thresholds estimated patientRisk() function split patients respectively 2 3 groups, described legend previous figure. Note implemented algorithm capable detecting changes slope risk curve, giving rise risk groups differenciated prognosis. Log-rank p-values minimum optimal versus number genes selected model. regularization parameter UNICOX increases, regression model becomes especific selection features , therefore number genes non-zero (non-null) coefficients reduced. patientRisk() function offers multiple values regularization parameter, user can choose value minimizes log-rank p-value, re-evaluate everything new gene list. case study optimal value achieved 12 genes. Biotechnologists, physicians, researchers general often prefer smaller set selected genes (selected features) risk markers, expense slight increase p-value. Taken together, representation allows us choose optimal number genes achieve balance lowest (significant) log-rank p-value fewest number selected genes. subset genes selected, corresponding COX model can retrieved list objects returned patientRisk() function. Finally, risk score new patients (placed independent query) can estimated considering constructed model predictor (explained next section). Note patientRisk() function can applied subset genes provided user (related unrelated clinical variable). Thus, function can applied study association gene risk select best gene risk markers (.e., providing gene signature risk markers). study, considering selected gene signature, patientRisk() function provides accurate risk prediction patient tumor sample also stratification patients low, intermediate high risk. Figure @ref(fig:plot4risk) presents genes selected multivariate COX model, ranked value regression coefficients model. Genes “positive” values (red) increase hazard ratio (HR) , therefore, increase risk samples (can associated oncogenic effect). genes “negative” values (blue) reduce HR risk samples (can associated tumor suppression protective effect). absolute value coefficients determines relevance gene respect patient’s risk. Plot genes selected multivariate COX model, ranked value regression coefficients model. Genes positive values (red) increase risk samples. genes negative values (blue) reduce risk samples. Genes significant p-values marked asterisks (** p-value<0.01, * p-value<0.05). Similarly, genes slightly significance level marked dot (· 0.1 0.05). analyses carried part multivariate take account additive interactions among genes. Table 2: List genes relevance risk assignement. Kaplan Meier plot: Blue (low risk) red (high risk) two groups samples different survival obtained stratification multivariate risk curve (Figure 6).","code":""},{"path":"/articles/asuri.html","id":"risk-prediction-for-an-independent-set-of-patients-predict-patientrisk","dir":"Articles","previous_headings":"Survival and risk assessment (case study on Breast Cancer).","what":"Risk Prediction for an independent set of patients: predict.patientRisk()","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"relevant goal medical doctors predict risk cancer patients considering level certain molecular markers. prediction implemented function predict.patientRisk() using multivariate model takes account cooperative work genes carry biological function. multivariate risk predictor trained patientRisk() function (see previous section), predict.patientRisk function may applied predict risk new patients considering gene expression small subset genes associated risk. Moreover, patients can classified low, intermediate high risk groups considering value risk score. following lines show predict risk score independent set patients. function plots risk score stratifies patients three groups.  input parameters function predict.patientRisk() : model.fit list containing pre-fitted model necessary parameters risk prediction, including optimal lambda value, risk thresholds, plot values given patientRisk() function. mExpr.testData data frame independent set patients representing gene expression data, row gene column sample. genes must subset genes (rows) considered training COX model using patientRisk function. colnames(mExpr) corresponds sample names rownames(mExpr) gene names. output function predict.patientRisk() risk plot list two objects: risk_score: unscaled risk score provided multivariate COX regression. scaled_risk_score: scaled risk score (0-100) independent set patients. Risk score prediction independent set patients using optimal multivariate COX model trained function patientRisk(). Green blue/red lines correspond optimal thresholds split patients two three groups respectively. thresholds learned training phase. function can applied also predict risk single patient given gene expression profile. mExprs_testData contain now column expression level list genes selected. single patient considered, function print normalized risk test patient classification three possible groups: Low, Intermediate High. Treatment intermediate group uncertain studied care.","code":""},{"path":"/articles/asuri.html","id":"survival-estimation-from-the-cox-regression-for-a-test-patient-predsurvcurve","dir":"Articles","previous_headings":"Survival and risk assessment (case study on Breast Cancer).","what":"Survival estimation from the COX regression for a test patient: predSurvCurve()","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"function predSurvCurve() obtain expected survival curve test patient estimated risk score predicted multivariate COX regression model considering Breslow estimator baseline Hazard. function provides plot expected survival curve. input parameters : cox_pred_training numeric vector representing predicted risk scores (log-risk scores) COX model training set. can obtained predict.patientRisk() function. mSurv data frame two columns: “time” representing survival times, “status” representing event status (1 event, 0 censored). cox_pred_test numeric vector length 1 representing predicted risk score (log-risk score) test patient. can obtained predict.patientRisk() function. eval_surv_times numeric vector times survival curve evaluated. NULL (default), times taken training data maximum event time.  output function list three objects: eval_times: Vector times survival curve evaluated. S_0_t: Vector baseline survival probability estimated eval_times. S_test_patient: Vector survival probability eval_times test patient. Survival curve estimation single patient based risk score predicted multivariate COX model. blue line shows median survival time survival probability drops 0.5.","code":""},{"path":"/articles/asuri.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"ASURI: An R Package for Survival Analysis and Risk Prediction using Gene Expression","text":"","code":"## ─ Session info ─────────────────────────────────────────────────────────────── ##  setting  value ##  version  R version 4.4.3 (2025-02-28) ##  os       Ubuntu 24.04.2 LTS ##  system   x86_64, linux-gnu ##  ui       X11 ##  language en ##  collate  es_ES.UTF-8 ##  ctype    es_ES.UTF-8 ##  tz       Europe/Madrid ##  date     2025-04-24 ##  pandoc   3.1.3 @ /usr/bin/ (via rmarkdown) ##  quarto   1.3.353 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/quarto ##  ## ─ Packages ─────────────────────────────────────────────────────────────────── ##  package      * version    date (UTC) lib source ##  asuri        * 0.99.0     2025-04-24 [1] Bioconductor ##  Biobase      * 2.66.0     2025-03-07 [2] bioc_git2r (@2cd604f) ##  BiocGenerics * 0.52.0     2025-03-07 [2] bioc_git2r (@1422115) ##  BiocManager    1.30.25    2024-08-28 [2] CRAN (R 4.4.3) ##  BiocStyle    * 2.34.0     2025-03-07 [2] bioc_git2r (@0a04242) ##  bitops         1.0-9      2024-10-03 [2] CRAN (R 4.4.3) ##  bookdown       0.42       2025-01-07 [2] CRAN (R 4.4.3) ##  bootstrap      2019.6     2019-06-17 [2] CRAN (R 4.4.3) ##  bslib          0.9.0      2025-01-30 [2] CRAN (R 4.4.3) ##  cachem         1.1.0      2024-05-16 [2] CRAN (R 4.4.3) ##  caTools        1.18.3     2024-09-04 [2] CRAN (R 4.4.3) ##  cli            3.6.4      2025-02-13 [2] CRAN (R 4.4.3) ##  codetools      0.2-20     2024-03-31 [2] CRAN (R 4.4.3) ##  colorspace     2.1-1      2024-07-26 [2] CRAN (R 4.4.3) ##  data.table     1.17.0     2025-02-22 [2] CRAN (R 4.4.3) ##  desc           1.4.3      2023-12-10 [2] CRAN (R 4.4.3) ##  devtools       2.4.5      2022-10-11 [2] CRAN (R 4.4.3) ##  digest         0.6.37     2024-08-19 [2] CRAN (R 4.4.3) ##  dplyr          1.1.4      2023-11-17 [2] CRAN (R 4.4.3) ##  ellipsis       0.3.2      2021-04-29 [2] CRAN (R 4.4.3) ##  evaluate       1.0.3      2025-01-10 [2] CRAN (R 4.4.3) ##  farver         2.1.2      2024-05-13 [2] CRAN (R 4.4.3) ##  fastmap        1.2.0      2024-05-15 [2] CRAN (R 4.4.3) ##  foreach        1.5.2      2022-02-02 [2] CRAN (R 4.4.3) ##  formatR      * 1.14       2023-01-17 [2] CRAN (R 4.4.3) ##  fs             1.6.5      2024-10-30 [2] CRAN (R 4.4.3) ##  future         1.34.0     2024-07-29 [2] CRAN (R 4.4.3) ##  future.apply   1.11.3     2024-10-27 [2] CRAN (R 4.4.3) ##  generics       0.1.3      2022-07-05 [2] CRAN (R 4.4.3) ##  ggplot2      * 3.5.1      2024-04-23 [2] CRAN (R 4.4.3) ##  glmnet       * 4.1-8      2023-08-22 [2] CRAN (R 4.4.3) ##  globals        0.16.3     2024-03-08 [2] CRAN (R 4.4.3) ##  glue           1.8.0      2024-09-30 [2] CRAN (R 4.4.3) ##  gplots       * 3.2.0      2024-10-05 [2] CRAN (R 4.4.3) ##  gtable         0.3.6      2024-10-25 [2] CRAN (R 4.4.3) ##  gtools         3.9.5      2023-11-20 [2] CRAN (R 4.4.3) ##  htmltools      0.5.8.1    2024-04-04 [2] CRAN (R 4.4.3) ##  htmlwidgets    1.6.4      2023-12-06 [2] CRAN (R 4.4.3) ##  httpuv         1.6.15     2024-03-26 [2] CRAN (R 4.4.3) ##  iterators      1.0.14     2022-02-05 [2] CRAN (R 4.4.3) ##  jquerylib      0.1.4      2021-04-26 [2] CRAN (R 4.4.3) ##  jsonlite       1.9.1      2025-03-03 [2] CRAN (R 4.4.3) ##  KernSmooth     2.23-26    2025-01-01 [2] CRAN (R 4.4.3) ##  knitr        * 1.49       2024-11-08 [2] CRAN (R 4.4.3) ##  labeling       0.4.3      2023-08-29 [2] CRAN (R 4.4.3) ##  later          1.4.1      2024-11-27 [2] CRAN (R 4.4.3) ##  lattice        0.22-6     2024-03-20 [2] CRAN (R 4.4.3) ##  lava           1.8.1      2025-01-12 [2] CRAN (R 4.4.3) ##  lifecycle      1.0.4      2023-11-07 [2] CRAN (R 4.4.3) ##  listenv        0.9.1      2024-01-29 [2] CRAN (R 4.4.3) ##  magrittr       2.0.3      2022-03-30 [2] CRAN (R 4.4.3) ##  MASS           7.3-65     2025-02-28 [2] CRAN (R 4.4.3) ##  Matrix       * 1.7-2      2025-01-23 [2] CRAN (R 4.4.3) ##  memoise        2.0.1      2021-11-26 [2] CRAN (R 4.4.3) ##  mime           0.12       2021-09-28 [2] CRAN (R 4.4.3) ##  miniUI         0.1.1.1    2018-05-18 [2] CRAN (R 4.4.3) ##  multtest     * 2.62.0     2025-03-07 [2] bioc_git2r (@b2a4744) ##  munsell        0.5.1      2024-04-01 [2] CRAN (R 4.4.3) ##  parallelly     1.42.0     2025-01-30 [2] CRAN (R 4.4.3) ##  pillar         1.10.1     2025-01-07 [2] CRAN (R 4.4.3) ##  pkgbuild       1.4.6      2025-01-16 [2] CRAN (R 4.4.3) ##  pkgconfig      2.0.3      2019-09-22 [2] CRAN (R 4.4.3) ##  pkgdown        2.1.1      2024-09-17 [2] CRAN (R 4.4.3) ##  pkgload        1.4.0      2024-06-28 [2] CRAN (R 4.4.3) ##  prodlim      * 2024.06.25 2024-06-24 [2] CRAN (R 4.4.3) ##  profvis        0.4.0      2024-09-20 [2] CRAN (R 4.4.3) ##  promises       1.3.2      2024-11-28 [2] CRAN (R 4.4.3) ##  purrr          1.0.4      2025-02-05 [2] CRAN (R 4.4.3) ##  R6             2.6.1      2025-02-15 [2] CRAN (R 4.4.3) ##  ragg           1.3.3      2024-09-11 [2] CRAN (R 4.4.3) ##  rbibutils      2.3        2024-10-04 [2] CRAN (R 4.4.3) ##  Rcpp           1.0.14     2025-01-12 [2] CRAN (R 4.4.3) ##  Rdpack       * 2.6.2      2024-11-15 [2] CRAN (R 4.4.3) ##  remotes        2.5.0      2024-03-17 [2] CRAN (R 4.4.3) ##  rlang          1.1.5      2025-01-17 [2] CRAN (R 4.4.3) ##  rmarkdown      2.29       2024-11-04 [2] CRAN (R 4.4.3) ##  rmeta          3.0        2018-03-20 [2] CRAN (R 4.4.3) ##  ROCR         * 1.0-11     2020-05-02 [2] CRAN (R 4.4.3) ##  rstudioapi     0.17.1     2024-10-22 [2] CRAN (R 4.4.3) ##  sass           0.4.9      2024-03-15 [2] CRAN (R 4.4.3) ##  scales       * 1.3.0      2023-11-28 [2] CRAN (R 4.4.3) ##  scrime         1.3.5      2018-12-01 [2] CRAN (R 4.4.3) ##  sessioninfo    1.2.3      2025-02-05 [2] CRAN (R 4.4.3) ##  shape          1.4.6.1    2024-02-23 [2] CRAN (R 4.4.3) ##  shiny          1.10.0     2024-12-14 [2] CRAN (R 4.4.3) ##  siggenes     * 1.80.0     2025-03-07 [2] bioc_git2r (@18cb74e) ##  SuppDists      1.1-9.8    2024-09-03 [2] CRAN (R 4.4.3) ##  survcomp     * 1.56.0     2025-03-07 [2] bioc_git2r (@1e00a05) ##  survival     * 3.8-3      2024-12-17 [2] CRAN (R 4.4.3) ##  survivalROC    1.0.3.1    2022-12-05 [2] CRAN (R 4.4.3) ##  systemfonts    1.2.1      2025-01-20 [2] CRAN (R 4.4.3) ##  textshaping    0.3.7      2023-10-09 [4] CRAN (R 4.3.1) ##  tibble         3.2.1      2023-03-20 [2] CRAN (R 4.4.3) ##  tidyselect     1.2.1      2024-03-11 [2] CRAN (R 4.4.3) ##  urlchecker     1.0.1      2021-11-30 [2] CRAN (R 4.4.3) ##  usethis        3.1.0      2024-11-26 [2] CRAN (R 4.4.3) ##  vctrs          0.6.5      2023-12-01 [2] CRAN (R 4.4.3) ##  withr          3.0.2      2024-10-28 [2] CRAN (R 4.4.3) ##  xfun           0.51       2025-02-19 [2] CRAN (R 4.4.3) ##  xtable         1.8-4      2019-04-21 [2] CRAN (R 4.4.3) ##  yaml           2.3.10     2024-07-26 [2] CRAN (R 4.4.3) ##  ##  [1] /tmp/Rtmp177AcV/temp_libpath79bc3225e0111 ##  [2] /home/alberto/R/x86_64-pc-linux-gnu-library/4.4 ##  [3] /usr/local/lib/R/site-library ##  [4] /usr/lib/R/site-library ##  [5] /usr/lib/R/library ##  * ── Packages attached to the search path. ##  ## ──────────────────────────────────────────────────────────────────────────────"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alberto Berral-Gonzalez. Author, maintainer, contributor. Santiago Bueno-Fortes. Author, contributor. Natalia Alonso-Moreda. Author, contributor. Jose Manuel Sanchez-Santos. Author, contributor. Manuel Martin-Merino Acera. Author, contributor. Javier De Las Rivas. Author, contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Berral-Gonzalez , Bueno-Fortes S, Alonso-Moreda N, Sanchez-Santos J, Martin-Merino Acera M, De Las Rivas J (2025). asuri: Analysis SUrvival RIsk prediction patients based gene signatures. R package version 0.99.0, https://github.com/jdelasrivas-lab/asuri.","code":"@Manual{,   title = {asuri: Analysis of SUrvival and RIsk prediction in patients based on gene signatures},   author = {Alberto Berral-Gonzalez and Santiago Bueno-Fortes and Natalia Alonso-Moreda and Jose Manuel Sanchez-Santos and Manuel {Martin-Merino Acera} and Javier {De Las Rivas}},   year = {2025},   note = {R package version 0.99.0},   url = {https://github.com/jdelasrivas-lab/asuri}, }"},{"path":"/index.html","id":"analysis-of-disease-survival-and-patient-risk-prediction-based-on-gene-signatures","dir":"","previous_headings":"","what":"Analysis of SUrvival and RIsk prediction in patients based on gene signatures","title":"Analysis of SUrvival and RIsk prediction in patients based on gene signatures","text":"S. Bueno-Fortes, . Berral-Gonzalez, J.M. Sanchez-Santos, M. Martin-Merino Acera J. De Las Rivas -Bioinformatics Functional Genomics Group- Cancer Research Centre (CiC-IBMCC, USAL/CSIC/IBSAL) Salamanca (Spain) Introduction: Modern medicine based omic technologies provides new approach study diseases renders way interrogate role genes biomolecular markers associated risk, prognosis, outcome patients. regard, discovery validation survival biomarkers associated given phenotype specific clinical variable critical step achieve better disease prognosis prediction. Furthermore, accurate risk prediction patients stratification based predictions help advance personalized treatments precision medicine. Currently, many tools available discover genetic survival markers assess prognostic capacity specific gene signatures. Moreover, common gene signatures discovered reproducible robust, correlated well clinical phenotypes, stages outcome disease. Besides, easy integrated tools providing molecular based assessment patients risk survival. Results: asuri package provides integrated set functions analyse disease SURVIVAL provide patient RISK predictions based gene signatures. tool allows: (1) Discovery robust reproducible gene lists associated disease survival based gene expression another gene-related activity signal (geneSurv); (2) Discovery gene markers identification significant association gene expression (gene-related signal) clinical variables phenotypic characteristics (genePheno); (3) Construction robust patient risk predictors based gene signatures using univariate multivariate approaches (patientRisk). Availability implementation: R package asuri (including source code) available Bioconductor web page. package requires R version >= 3.6.","code":""},{"path":"/reference/genePheno.html","id":null,"dir":"Reference","previous_headings":"","what":"genePheno — genePheno","title":"genePheno — genePheno","text":"function implements robust algorithms obtain list genes associated given clinical variable. based elastic net algorithm robustness reproducibility subset genes improved using bootstrap strategy combined ensemble methods.","code":""},{"path":"/reference/genePheno.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"genePheno — genePheno","text":"","code":"genePheno(mExpr, vectorGroups, vectorSampleID, iter = 100, numberOfFolds = 10)"},{"path":"/reference/genePheno.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"genePheno — genePheno","text":"mExpr matrix normalized gene expression data. Rows correspond samples, columns correspond genes. `rownames(mExpr)` set sample names, `colnames(mExpr)` set gene names. vectorGroups Clinical variable. must provided numeric binary vector. vectorSampleID Vector containing sample names ordered expression matrix. iter Number bootstrap iterations (default: 100, changed function takes long execute). numberOfFolds Number folds implement nested cross-validation. default 10.","code":""},{"path":"/reference/genePheno.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"genePheno — genePheno","text":"function implements robust version elastic net algorithm proposed Tibshirani (Tibshirani et al., 2009). algorithm considers penalty term avoid overfitting convex combination L2 norm (ridge regression) L1 (Lasso regression). alpha parameter 1, regularization term perfoms similarly Lasso minimizes number non-null coefficients. subset features slightly correlated Lasso selects one randomly. avoid extreme behavior alpha parameter set 0.75 includes relevant variables Lasso improves prediction accuracy. Besides, choice help improve stability reduce variance feature selection process. order improve robustness reproducibility gene signature discovered, bootstrap strategy implemented. patients resampled replacement giving rise B replicates.   replicate gene signature obtained using double nested cross-validation avoid overfitting. final gene list built ensemble lists, considereing several metrics evaluate stability, robustness predictive power gene. See (Martinez-Romero et al., 2018) details.","code":""},{"path":"/reference/genePheno.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"genePheno — genePheno","text":"list provided following objects: genes list genes ranked according degree association clinical phenotypic variable tested. listCoeff list beta regression coefficients AUC score bootstrap iteration. stability Gene selection probability estimated bootstrap (number times discovered \"n\" iterations). betasMedian Median beta coefficients B replicates. betasMean Mean beta coefficients B replicates. betasTable Table genes ordered decreasing value stability coefficient. Contains several metrics: stability index, mean median beta coefficients.","code":""},{"path":"/reference/genePheno.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"genePheno — genePheno","text":"Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/genePheno.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"genePheno — genePheno","text":"","code":"data(genePheno)    # Gene expression matrix filtered by SAM differential expression function   mExprsDE <- mExprs[match(DE_list_genes, rownames(mExprs)), ]   dim(mExprsDE) #> [1] 865 200   # [1] 865  200   tmExprsDE <- t(mExprsDE)   # Parameters: Number of bootstrap iterations: 100.   # The object `tmExprsDE` is the gene expression matrix for the subset of genes tested (samples as rows and genes as columns). The object `mPheno$ER.IHC` is a vector indicating the value per-sample of ER (as a binary variable: \"0\" or \"1\").   vectorSampleID <- as.character(rownames(mPheno))   vectorGroups <- as.numeric(mPheno$ER.IHC)   Pred_ER.IHC <- genePheno(tmExprsDE, vectorGroups, vectorSampleID) #> 2025-04-24 12:23:45.090769 #>  Progress: 10 % #>  Progress: 20 % #>  Progress: 30 % #>  Progress: 40 % #>  Progress: 50 % #>  Progress: 60 % #>  Progress: 70 % #>  Progress: 80 % #>  Progress: 90 % #>  Progress: 100 %    # Pred_ER.IHC is an output object with the list of genes that show a significant correlation with the clinical variable. Since a bootstrap is performed, the results of how many times across iterations a gene is found significant are reported as *stability* (in relative numbers 0-1, 1=100%) and the *beta values* from the regression across iterations are also provided as *betaMedian* and *betaMean* :    names(Pred_ER.IHC) #> [1] \"genes\"       \"listCoeff\"   \"stability\"   \"betasMedian\" \"betasMean\"   #> [6] \"betasTable\"    # [1] \"genes\" \"listCoeff\" \"stability\" \"betasMedian\" \"betasMean\" \"betasTable\""},{"path":"/reference/geneSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"geneSurv — geneSurv","title":"geneSurv — geneSurv","text":"function analyzes ability gene mark survival based robust version KM curves. robust K-M estimator obtained bootstrap strategy.","code":""},{"path":"/reference/geneSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"geneSurv — geneSurv","text":"","code":"geneSurv(genExpr, time, status, geneName, boxplot = T, iter = 100, type = c(\"exprs\", \"risk\"), cut_time = 10)"},{"path":"/reference/geneSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"geneSurv — geneSurv","text":"genExpr Vector normalized gene expression sample. names(genExpr) contains sample names. time Numeric vector containing survival time sample years, including sample name names(time). status Numeric vector status (censored 0 censored 1) sample. names(status) shoud include sample names. geneName character string name gene analyzed. boxplot logical value indicating whether generate boxplot gene expression survival group (default = TRUE). iter number iterations (bootstrap resampling) calculating optimal group cutoffs (default = 100). type Defines KM curve groups computed using risk (\"risk\") gene expression (default \"exprs\"). cut_time numeric value specifying cutoff time (years) survival analysis. events beyond time treated censored (default = 10 years).","code":""},{"path":"/reference/geneSurv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"geneSurv — geneSurv","text":"function improves stability robustness K-M estimator using bootstrap strategy. Patients resampled replacement giving rise B replicates. K-M estimator obtained based replicates well confidence intervals. patients stratified two risk groups expression threshold optimizes log-rank statistics, separability Kaplan-Meier curves group. function implements novel method find optimal threshold avoiding problems instability unbalanced classes suffer implementations. Besides, membership probability risk group estimated classification sample replicates. membership probability allow us reclassify patients around gene expression threshold robust way. function provides robust estimation log-rank p-value Hazard ratio allow us evaluate ability given gene mark survival.","code":""},{"path":"/reference/geneSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"geneSurv — geneSurv","text":"Depending type run, output changes. \"type = exprs\": Kaplan-Meier plot based expression groups, differential expression boxplot plot membership probability risk group. Additionally, object following components: geneName character string name gene analyzed. patientExpr expression level patient given gene. patientClass Vector group classification according gene expression level: 2 = high expression 1 = low expression level. patientClassProbality Vector membership probabilities classification. wilcox.pvalue p-value Wilcoxon test comparing two expression groups. plot_values list containing Kaplan-Meier fit results, log-rank p-value, hazard ratio.  \"type = risk\": Kaplan-Meier plot based risk groups. Additionally, object following components: geneName character string name gene analyzed. patientExpr expression level patient given gene. risk_score_predicted numeric vector predicted relative risk scores patient. plot_values list containing Kaplan-Meier fit results, log-rank p-value, hazard ratio.","code":""},{"path":"/reference/geneSurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"geneSurv — geneSurv","text":"Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/geneSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"geneSurv — geneSurv","text":"","code":"data(geneSurvExprs)      genExpr <- mExprs[match(\"ESR1\", rownames(mExprs)), ]   time <- mPheno$time   names(time) <- rownames(mPheno)   status <- mPheno$status   names(status) <- rownames(mPheno)      # The TIME value must be transformed to YEARS   # The gene expression vector must be provided with the NAMES of each sample,   # that should match the time and status NAMES.   set.seed(5)   outputKM <- geneSurv(genExpr, time, status, \"ESR1\", type = \"exprs\") #> samples ok #> 2025-04-24 12:26:18.361297 #>  Progress: 1 of 100 #>  Progress: 2 of 100 #>  Progress: 3 of 100 #>  Progress: 4 of 100 #>  Progress: 5 of 100 #>  Progress: 6 of 100 #>  Progress: 7 of 100 #>  Progress: 8 of 100 #>  Progress: 9 of 100 #>  Progress: 10 of 100 #>  Progress: 11 of 100 #>  Progress: 12 of 100 #>  Progress: 13 of 100 #>  Progress: 14 of 100 #>  Progress: 15 of 100 #>  Progress: 16 of 100 #>  Progress: 17 of 100 #>  Progress: 18 of 100 #>  Progress: 19 of 100 #>  Progress: 20 of 100 #>  Progress: 21 of 100 #>  Progress: 22 of 100 #>  Progress: 23 of 100 #>  Progress: 24 of 100 #>  Progress: 25 of 100 #>  Progress: 26 of 100 #>  Progress: 27 of 100 #>  Progress: 28 of 100 #>  Progress: 29 of 100 #>  Progress: 30 of 100 #>  Progress: 31 of 100 #>  Progress: 32 of 100 #>  Progress: 33 of 100 #>  Progress: 34 of 100 #>  Progress: 35 of 100 #>  Progress: 36 of 100 #>  Progress: 37 of 100 #>  Progress: 38 of 100 #>  Progress: 39 of 100 #>  Progress: 40 of 100 #>  Progress: 41 of 100 #>  Progress: 42 of 100 #>  Progress: 43 of 100 #>  Progress: 44 of 100 #>  Progress: 45 of 100 #>  Progress: 46 of 100 #>  Progress: 47 of 100 #>  Progress: 48 of 100 #>  Progress: 49 of 100 #>  Progress: 50 of 100 #>  Progress: 51 of 100 #>  Progress: 52 of 100 #>  Progress: 53 of 100 #>  Progress: 54 of 100 #>  Progress: 55 of 100 #>  Progress: 56 of 100 #>  Progress: 57 of 100 #>  Progress: 58 of 100 #>  Progress: 59 of 100 #>  Progress: 60 of 100 #>  Progress: 61 of 100 #>  Progress: 62 of 100 #>  Progress: 63 of 100 #>  Progress: 64 of 100 #>  Progress: 65 of 100 #>  Progress: 66 of 100 #>  Progress: 67 of 100 #>  Progress: 68 of 100 #>  Progress: 69 of 100 #>  Progress: 70 of 100 #>  Progress: 71 of 100 #>  Progress: 72 of 100 #>  Progress: 73 of 100 #>  Progress: 74 of 100 #>  Progress: 75 of 100 #>  Progress: 76 of 100 #>  Progress: 77 of 100 #>  Progress: 78 of 100 #>  Progress: 79 of 100 #>  Progress: 80 of 100 #>  Progress: 81 of 100 #>  Progress: 82 of 100 #>  Progress: 83 of 100 #>  Progress: 84 of 100 #>  Progress: 85 of 100 #>  Progress: 86 of 100 #>  Progress: 87 of 100 #>  Progress: 88 of 100 #>  Progress: 89 of 100 #>  Progress: 90 of 100 #>  Progress: 91 of 100 #>  Progress: 92 of 100 #>  Progress: 93 of 100 #>  Progress: 94 of 100 #>  Progress: 95 of 100 #>  Progress: 96 of 100 #>  Progress: 97 of 100 #>  Progress: 98 of 100 #>  Progress: 99 of 100 #>  Progress: 100 of 100 #> 200                                   # Generate the plots again   ## Plots for c(type = exprs)   asuri:::plotBoxplot(outputKM)    asuri:::plotProbClass(outputKM)    asuri:::plotKM(outputKM)       # If we instead consider to run the function as *type* = risk   data(geneSurvRisk)      genExpr <- mExprs[match(\"BRCA1\", rownames(mExprs)), ]   time <- mPheno$time   names(time) <- rownames(mPheno)   status <- mPheno$status   names(status) <- rownames(mPheno)   set.seed(5)   outputKM.TP53 <- geneSurv(genExpr, time, status, \"BRCA1\", type = \"risk\")     ## Plots for c(type = risk)   asuri:::plotKM(outputKM)"},{"path":"/reference/patientRisk.html","id":null,"dir":"Reference","previous_headings":"","what":"patientRisk — patientRisk","title":"patientRisk — patientRisk","text":"function selects subset good risk markers estimates multivariate risk score based UNICOX algorithm. patients stratified two prognostic groups based risk score. Cox regression trained using ten-fold double nested crossvalidation strategy avoid overfitting.","code":""},{"path":"/reference/patientRisk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"patientRisk — patientRisk","text":"","code":"patientRisk(mExpr, time, status,    method = c(\"min.pval\", \"med.pval\", \"class.probs\"), nboot = 50)"},{"path":"/reference/patientRisk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"patientRisk — patientRisk","text":"mExpr numeric matrix gene expression data row represents gene column represents sample. time numeric vector representing survival time sample, names(time) defined sample names. status numeric vector representing event status (1 = event, 0 = censored) sample, names(status) defined sample names. group.vector numeric vector specifying predefined risk groups patients. optional. method character string specifying method defining risk groups. Possible options : \"min.pval\": Defines risk groups based minimum log-rank p-value. \"med.pval\": Defines risk groups based median log-rank p-values. \"class.probs\": Defines risk groups based classification probabilities model. NULL, default method \"class.probs\". nboot integer specifying number bootstrap iterations risk score calculation. Default 50.","code":""},{"path":"/reference/patientRisk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"patientRisk — patientRisk","text":"multivariate Cox regression trained select subset genes significantly associated risk estimate risk score based risk markers. algorithm considered based UNICOX, regularized multivariate Cox regression model (see Tibshirani et al., 2009 details). predictor, variables penalized individually using \\(L_1\\) norm term allow us keep relevant genes correlated risk Lasso. Lasso model selects one representative gene randomly set correlated genes. optimal value lambda parameter well risk score estimated using double nested crossvalidation strategy. Finally, risk score allow us stratify whole set patients according risks. Three algorithms implemented estimate optimal threshold classifies patients risk groups. \"min.pval\" determines optimal threshold minimization log-rank p-value statistics,  maximization separability K-M curves high low risk groups, see  (Martinez-Romero et al., 2018). several local minima arise may sample dependent unstable. avoid problem, \"med.pval\" estimates optimal threshold median lower 10th percentile logrank p-values. lower 10th percentile selects smallest values p-value distribution corresponding intermediate risk patients boundary groups. interval robust single minimum provides good experimental results large variety problems tested. median threshold interval may change one iteration another distribution p-values patients intermediate risk may change due sample variations. Finally, \"class.probs\" implements bootstrap strategy patients corresponding lower 10th percentile p-values estimates robust threshold stratify patients. estimates also membership probability classification.","code":""},{"path":"/reference/patientRisk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"patientRisk — patientRisk","text":"function generate 5 plots: • Curve log-rank p-values possible splitting patients two risk groups considering risk score. green line shows robust minimum selected provides threshold stratify patients two risk groups. blue/red lines show thresholds stratify patients three risk groups (low, intermediate high). • Risk plot obtained multivariate Cox regression model (UNICOX) considering optimal subset genes correlated risk. green blue/red lines show thresholds stratify patients two three risk groups respectively. • Log-rank p-value versus number genes selected model. • Genes ranked value regression coefficients multivariate Cox model (UNICOX). Genes significant p-value marked asterisks following standard statistical convention. Similarly, genes significance level 0.1 0.05 marked period. • Kaplan Meier plot: Blue (low risk) red (high risk). Risk groups obtained stratification risk curve (plot 2). function also returns object containing: cv_risk_score Risk score prediction training set using double nested crossvalidated strategy cv_normalized_risk Normalized risk score interval (0,100). table_genes_selected Data frame following columns: names genes selected Cox regression, beta coefficients optimal multivariate Cox regression fitted training set, Hazard Ratio gene p-value univariate log-rank statistical test. Genes shown descending order HR index. table_genes_selected_extended Table format table_genes_selected. search local minima within 5% range selected minimum performed. goal expanding list significant genes improve biological interpretability, since lasso penalty drastically reduces number significant genes. model.optimalLambda fitted model optimal regularization parameter. groups Vector classification patients two risk groups, high (2) low (1). riskThresholds Thresholds allows stratify test patients three groups according predicted risk score: low, intermediate high risk. range.risk Range unscaled risk score training set. list.models List models tested different values regularization parameter. evaluation.models Data frame provides several metrics model evaluated. lambda column provides regularization parameter multivariate Cox regression adjusted, number_features gives number genes selected model, c.index se.c.index concordance index standard deviation risk prediction finally, p_value_c.index logrank_p_value give p-values concordance index log-rank statistics respectively. Models shown ascending order log-rank p-value best one marked two asterisks. betasplot Dataset used create plot genes ranked according regression coefficients multivariate Cox model (UNICOX). plot_values list containing Kaplan-Meier fit results, logrank p-value, hazard ratio. membership_prob method \"class.probs\" selected table two columns returned. first one probability classification low risk group second one membership probability high risk group.","code":""},{"path":"/reference/patientRisk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"patientRisk — patientRisk","text":"Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/patientRisk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"patientRisk — patientRisk","text":"","code":"data(patientRisk)    # Survival times should be provided in YEARS   time <- mPheno$time   names(time) <- rownames(mPheno)   status <- mPheno$status   names(status) <- rownames(mPheno)    # Pred_ER.IHC$genes is the subset of genes to be tested. In our case study,   # it is the list of genes related to the ER clinical variable that was   # obtained using the function **genePheno()**.   geneList <- names(Pred_ER.IHC$genes)      # Next, the expression matrix for the list of genes selected is obtained.   mExprSelectedGenes <- mExprs[match(geneList, rownames(mExprs)), ]    # Training of the multivariate COX model. Provide the expression matrix   # (genes as rows and samples as columns) for the list of genes selected,   # the time and the status vectors, and the method to stratify the patients   # (select one of these methods: `min.pval`, `med.pval`, `class.probs`).   set.seed(5)   multivariate_risk_predictor <- patientRisk(mExprSelectedGenes, time, status, method = \"class.probs\") #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #> Nested ten fold cross validation: Predicting the risk for each lambda... #>  Progress: 10 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 20 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 30 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 40 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 50 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 60 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 70 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 80 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 90 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #>  Progress: 100 % #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #> Risk predicted! #> Nested Cross Validation: optimizing lambda... #>  Progress: 3% #>  Progress: 7% #>  Progress: 10% #>  Progress: 13% #>  Progress: 17% #>  Progress: 20% #>  Progress: 23% #>  Progress: 27% #>  Progress: 30% #>  Progress: 33% #>  Progress: 37% #>  Progress: 40% #>  Progress: 43% #>  Progress: 47% #>  Progress: 50% #>  Progress: 53% #>  Progress: 57% #>  Progress: 60% #>  Progress: 63% #>  Progress: 67% #>  Progress: 70% #>  Progress: 73% #>  Progress: 77% #>  Progress: 80% #>  Progress: 83% #>  Progress: 87% #>  Progress: 90% #>  Progress: 93% #>  Progress: 97% #>  Progress: 100% #>  #> Risk predicted! #> lambda value 1out of 30TRUE #> lambda value 2out of 30TRUE #> lambda value 3out of 30TRUE #> lambda value 4out of 30TRUE #> lambda value 5out of 30TRUE #> lambda value 6out of 30TRUE #> lambda value 7out of 30TRUE #> lambda value 8out of 30TRUE #> lambda value 9out of 30TRUE #> lambda value 10out of 30TRUE #> lambda value 11out of 30TRUE #> lambda value 12out of 30TRUE #> lambda value 13out of 30TRUE #> lambda value 14out of 30TRUE #> lambda value 15out of 30TRUE #> lambda value 16out of 30TRUE #> lambda value 17out of 30TRUE #> lambda value 18out of 30TRUE #> lambda value 19out of 30TRUE #> lambda value 20out of 30TRUE #> lambda value 21out of 30TRUE #> lambda value 22out of 30TRUE #> lambda value 23out of 30TRUE #> lambda value 24out of 30TRUE #> lambda value 25out of 30TRUE #> lambda value 26out of 30TRUE #> lambda value 27out of 30TRUE #> lambda value 28out of 30TRUE #> lambda value 29out of 30TRUE #> lambda value 30out of 30TRUE #> lambda value 1out of 1TRUE #> lambda value 1out of 1TRUE #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100% #>  Progress: 100%         # Generate the plots again   asuri:::plotLogRank(multivariate_risk_predictor)    asuri:::plotSigmoid(multivariate_risk_predictor)    asuri:::plotLambda(multivariate_risk_predictor)    asuri:::plotBetas(multivariate_risk_predictor)    asuri:::plotKM(multivariate_risk_predictor)"},{"path":"/reference/predSurvCurve.html","id":null,"dir":"Reference","previous_headings":"","what":"predSurvCurve — predSurvCurve","title":"predSurvCurve — predSurvCurve","text":"Function predict expected survival curve test patient given risk score provided Cox regression model.","code":""},{"path":"/reference/predSurvCurve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predSurvCurve — predSurvCurve","text":"","code":"predSurvCurve( cox_pred_training, mSurv, cox_pred_test, eval_surv_times = NULL )"},{"path":"/reference/predSurvCurve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predSurvCurve — predSurvCurve","text":"cox_pred_training numeric vector representing predicted risk scores (log-risk scores) Cox model training set. can obtained *predict.patientRisk* function. mSurv data frame two columns: \"time\" representing survival times, \"status\" representing event status (1 event, 0 censored) training dataset. cox_pred_test numeric vector length 1 representing predicted risk score (log-risk score) test patient. can obtained *predict.patientRisk* function. eval_surv_times numeric vector times survival curve evaluated. NULL (default), times taken training data maximum event time.","code":""},{"path":"/reference/predSurvCurve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"predSurvCurve — predSurvCurve","text":"function obtain expected survival curve test patient given risk score estimated multivariate Cox regression model. Breslow estimator considered approximate baseline Hazard. cumulative baseline survival function smoothed using Friedman's super smoother. function interpolates linearly survival probability time points training set.","code":""},{"path":"/reference/predSurvCurve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predSurvCurve — predSurvCurve","text":"function provides plot expected survival curve. shows also median survival time, , time survival probability drops 0.5.   function also returns list following objects: eval_times Vector times years survival curve evaluated. S_0_t Vector baseline survival probability estimated evaluation time. S_test_patient Vector survival probability estimated evaluation time given test patient.","code":""},{"path":"/reference/predSurvCurve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"predSurvCurve — predSurvCurve","text":"Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/predSurvCurve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"predSurvCurve — predSurvCurve","text":"","code":"data(predSurvCurve)      # COX prediction for the training set   set.seed(5)   cox_pred_training <- predict.patientRisk(multivariate_risk_predictor, mExprSelectedGenes)    cox_pred_training$risk_score #>    GSM491233    GSM540243    GSM540162    GSM540353    GSM540238    GSM540197  #>  0.794974646 -0.681587724  0.628877440  0.509780999  0.641865583 -0.891489008  #>    GSM447221    GSM540205    GSM491226    GSM540241    GSM491214    GSM540140  #>  0.589102923 -1.046099095 -0.397609723 -0.517601962 -0.481844371  0.565231240  #>    GSM540270    GSM540182    GSM540150    GSM540267    GSM491260    GSM540247  #> -0.330692030 -0.250508276 -0.726282168  0.336248198 -0.306032540 -0.927606531  #>    GSM491264    GSM540364    GSM540240    GSM540282    GSM491284    GSM491262  #> -0.344837523  0.637596957 -0.393924241  0.854486426  0.522117388 -0.581046627  #>    GSM540161    GSM491195    GSM491240    GSM447202    GSM540310    GSM540292  #> -0.219403852  0.464498323 -0.651585598 -0.142053848  0.549845582  0.585690181  #>    GSM540272    GSM447231    GSM491276    GSM540291    GSM447243    GSM540318  #>  0.516902612  0.131253139 -0.789568119  1.024277344 -0.955420327 -0.369948480  #>    GSM540342    GSM540328    GSM540253    GSM540370    GSM540167    GSM540319  #> -0.447607166 -0.219205014 -0.477420623  0.980114711  0.095025119 -0.768131354  #>    GSM540123    GSM491223    GSM540135    GSM491278    GSM540110    GSM540248  #>  0.933678908  0.931988575 -0.975401561 -0.264072934  0.055889753  0.533906925  #>    GSM540332    GSM540297    GSM540341    GSM491281    GSM491261    GSM447212  #> -0.354534227 -0.436061029 -0.864453342 -0.864035135 -0.490204702 -0.498585701  #>    GSM540125    GSM540179    GSM540235    GSM540126    GSM491222    GSM540229  #>  0.500922625 -0.400651106  0.261516585 -0.360551989 -0.700486553 -0.362458948  #>    GSM540178    GSM540201    GSM491267    GSM447205    GSM540284    GSM540118  #>  0.023503458  0.498925415 -0.603285234 -0.788250628 -0.413032102  0.382042676  #>    GSM540120    GSM540230    GSM447209    GSM491181    GSM540261    GSM540148  #> -0.405871811 -0.562381594  0.552437934  0.476263340  0.967338964 -0.778990887  #>    GSM540231    GSM491282    GSM540237    GSM540351    GSM540339    GSM540344  #> -0.318786787 -0.793087600  0.500093747  0.663986174  0.949067914 -0.633763936  #>    GSM447197    GSM491288    GSM540142    GSM540203    GSM491211    GSM540173  #>  0.617408897 -0.152466478 -0.568383120 -0.566699758  0.039410484 -0.726762253  #>    GSM540281    GSM491272    GSM491180    GSM540280    GSM491265    GSM540245  #>  0.638319178 -0.604439433  0.950501390 -0.344058950 -0.252004567 -0.403060556  #>    GSM540359    GSM540154    GSM491198    GSM540330    GSM491199    GSM540159  #>  0.740253963 -0.181718620  0.995363711 -0.328253368  0.650882475  0.455762677  #>    GSM540196    GSM540215    GSM540293    GSM447206    GSM540350    GSM491182  #> -0.048464995  0.495713353 -0.165993803  0.458307623  0.833496750  0.837228314  #>    GSM491219    GSM540337    GSM491204    GSM491231    GSM491263    GSM540371  #>  0.813582525 -0.904517574 -0.369419678  0.645825090 -0.616201197  0.446064604  #>    GSM447227    GSM491183    GSM540354    GSM540302    GSM540285    GSM491197  #> -0.282674222  0.854974984  0.272019486  0.905487744  0.706817722  0.888058296  #>    GSM447233    GSM540165    GSM540124    GSM540340    GSM540295    GSM491196  #> -0.579771958 -0.557923192  0.590214471 -0.107481272 -0.831604907  0.545018668  #>    GSM491191    GSM491279    GSM540277    GSM491234    GSM540166    GSM540273  #>  0.909951926 -0.005467978 -0.383290681 -0.181787703 -0.456630059  0.761567768  #>    GSM540363    GSM447215    GSM540268    GSM491269    GSM540219    GSM540299  #>  0.880313617  0.722293265  1.017307157 -0.611620506  0.748843899 -0.688590901  #>    GSM540213    GSM491238    GSM540233    GSM491227    GSM491257    GSM540356  #>  0.131400546  0.675354671 -0.470153182 -0.964564708 -0.315638752  0.556133571  #>    GSM540143    GSM540160    GSM540130    GSM491220    GSM540141    GSM540199  #> -0.302052246  0.165832662  0.403964921 -0.517077697 -0.361430390 -0.354970693  #>    GSM540109    GSM447207    GSM447232    GSM491242    GSM491246    GSM540347  #>  0.730270044 -1.324825189  0.390235265 -0.160417359 -0.707647295 -0.304237944  #>    GSM540157    GSM491259    GSM540362    GSM491184    GSM540334    GSM491203  #>  0.358018505 -0.614406250  0.483969244  0.692642414 -1.119258251  0.007772479  #>    GSM491229    GSM491268    GSM540265    GSM491202    GSM491245    GSM540144  #>  0.359191133 -0.732841436  0.612081133  0.887230704  1.434945962 -0.326795478  #>    GSM491193    GSM491189    GSM540137    GSM540188    GSM491221    GSM540266  #>  0.732130845  0.581510992 -0.347999654 -0.490966818 -0.514560060 -0.933858867  #>    GSM491252    GSM447226    GSM447216    GSM447198    GSM540172    GSM491275  #> -0.537298336  0.321934031 -0.161678464  0.566925069  0.836746533 -0.235081735  #>    GSM447199    GSM540249    GSM491280    GSM491178    GSM540220    GSM447208  #> -0.361261231  0.480987015 -1.084941759  0.759941718 -0.372148617 -0.953970457  #>    GSM540216    GSM540367    GSM540208    GSM540108    GSM540269    GSM540244  #> -0.095950104  0.758258480 -0.396851963  0.047783889 -0.565467348 -0.804141272  #>    GSM540195    GSM540286    GSM491228    GSM540369    GSM447245    GSM540322  #>  0.425527325 -1.000275669  0.461504343  0.367311431 -0.382339451 -0.735490645  #>    GSM540177    GSM540155    GSM540242    GSM540346    GSM540214    GSM491225  #> -0.635546876  0.375293584 -0.057143173  1.022823575  0.459705935 -0.808013599  #>    GSM540349    GSM491243  #>  0.882444715  0.706730129       # COX prediction for the test patient   set.seed(5)   cox_pred_test <- predict.patientRisk(multivariate_risk_predictor, mExprs_testSingleData) #> Normalized patient Risk (0 100): 27.9017675117161 #> The patient is classified as Low Risk  #> Low Risk interval: (0, 37.0600635839135)   cox_pred_test$risk_score #>    Sample4  #> -0.5548003       # Survival curve estimation   eval_surv_times <- seq(0, max(mPheno$time), by = 0.1)   set.seed(5)   surv_curv_cox <- predSurvCurve(cox_pred_training$risk_score, mPheno[, c(2, 3)], cox_pred_test$risk_score, eval_surv_times) #> The Survival curve is only estimated for the interval [%.1f, %.1f]07.66083333333333 #> No observation beyond this point in the training set"},{"path":"/reference/predict.patientRisk.html","id":null,"dir":"Reference","previous_headings":"","what":"predict.patientRisk — predict.patientRisk","title":"predict.patientRisk — predict.patientRisk","text":"Function predict risk new patients considering gene expression subset genes multivariate Cox regression model trained function patientRisk, may used predict single patient.","code":""},{"path":"/reference/predict.patientRisk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predict.patientRisk — predict.patientRisk","text":"","code":"predict.patientRisk(model.fit, mExpr.testData)"},{"path":"/reference/predict.patientRisk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predict.patientRisk — predict.patientRisk","text":"model.fit list containing pre-fitted model necessary parameters risk prediction, including optimal lambda value, risk thresholds, plot values given *patientRisk()* function. mExpr.testData data frame independent set patients representing gene expression data, row gene column sample. genes must subset genes (rows) considered training Cox model using patientRisk function. *colnames(mExpr)* corresponds sample names *rownames(mExpr)* gene names.","code":""},{"path":"/reference/predict.patientRisk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"predict.patientRisk — predict.patientRisk","text":"risk score estimated new patients considering optimal regularized multivariate Cox regression model trained function patientRisk. risk score normalized interpretable scale (0-100). function generates risk plot new patients stratifies three risk groups (low, intermediate, high) considering thresholds learned function patientRisk.","code":""},{"path":"/reference/predict.patientRisk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predict.patientRisk — predict.patientRisk","text":"function generates one plot risk new patients scaled interpretable range 0-100. Low risk pattients shown blue high risk patients red. expression profile single patient provided, function predicts risk classifies sample one three possible risk groups.   function also returns list following objects: risk_score vector unscaled risk score new patients estimated multivariate Cox regression model. scaled_risk_score vector risk score new patients scaled interpretable range 0-100.","code":""},{"path":"/reference/predict.patientRisk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"predict.patientRisk — predict.patientRisk","text":"Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/predict.patientRisk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"predict.patientRisk — predict.patientRisk","text":"","code":"data(predictPatientRisk)    # Generate the validation set, mExprs_testData if necessary.   # Vector of genes (same ones used in Cox model training)   genes <- rownames(mExprSelectedGenes)    # Simulate expression data   num_samples <- 20   set.seed(5)   mExprs_testData <- matrix(rnorm(length(genes) * num_samples, mean = 10, sd = 3),                             nrow = length(genes), ncol = num_samples)    # Assign row names (genes) and column names (samples)   rownames(mExprs_testData) <- genes   colnames(mExprs_testData) <- paste0(\"Sample\", 1:num_samples)    set.seed(5)   risk_prediction_validation_set <- predict.patientRisk(multivariate_risk_predictor, mExprs_testData)      # Example for single patient prediction: Patient fourth is selected.   mExprs_testSingleData <- data.frame(mExprs_testData[, 4])   colnames(mExprs_testSingleData) <- colnames(mExprs_testData)[4]   # Risk prediction for the optimal subset of genes selected by patientRisk function   set.seed(5)   risk_prediction_one_patient <- predict.patientRisk(multivariate_risk_predictor, mExprs_testSingleData) #> Normalized patient Risk (0 100): 27.9017675117161 #> The patient is classified as Low Risk  #> Low Risk interval: (0, 37.0600635839135)      # Normalized patient Risk (0 100): 27.9017675117161   # The patient is classified as Low Risk    # Low Risk interval: (0, 37.0600635839135)"},{"path":"/reference/prefilterSAM.html","id":null,"dir":"Reference","previous_headings":"","what":"prefilterSAM — prefilterSAM","title":"prefilterSAM — prefilterSAM","text":"R function pre-filter noisy genes, keeping relevant ones microarrays RNAseq data. genes can used later analysis.","code":""},{"path":"/reference/prefilterSAM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prefilterSAM — prefilterSAM","text":"","code":"prefilterSAM(mExpr, groups_vector, FDRfilter = 0.05, percentageFilter = 80, iter = 100)"},{"path":"/reference/prefilterSAM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prefilterSAM — prefilterSAM","text":"mExpr matrix rows represent genes columns represent samples. entry expression value gene sample. groups_vector binary vector indicating group assignment sample. FDRfilter numeric value indicating FDR threshold selecting significant genes. Default 0.05. iter number iterations bootstrapping. Default 100. percentageFilter numeric value indicating percentage iterations gene must appear considered significant. Default 80.","code":""},{"path":"/reference/prefilterSAM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"prefilterSAM — prefilterSAM","text":"function implements SAM (Schwender H., 2022) robust diferential expression analysis based bootstrap . helps remove noisy genes reducing computational complexity analysis.","code":""},{"path":"/reference/prefilterSAM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"prefilterSAM — prefilterSAM","text":"ordered vector names differentially expressed genes categories grouping vector. result list DE genes ordered SAM d.value filtered percentageFilter.","code":""},{"path":"/reference/prefilterSAM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"prefilterSAM — prefilterSAM","text":"Schwender H (2022). _siggenes: Multiple Testing using SAM Efron's Empirical Bayes Approaches_. R package version 1.72.0. Martinez-Romero, J., Bueno-Fortes, S., Martín-Merino, M. et al. (2018) Survival marker genes colorectal cancer derived consistent transcriptomic profiling. BMC Genomics 19 (Suppl 8), 857 . doi:10.1186/s12864-018-5193-9 Santiago Bueno-Fortes, Alberto Berral-Gonzalez, José Manuel Sánchez-Santos, Manuel Martin-Merino, Javier De Las Rivas (2023) Identification gene expression signature associated breast cancer survival risk improves clinical genomic platforms, Bioinformatics Advances, Volume 3, Issue 1, vbad037, doi:10.1093/bioadv/vbad037","code":""},{"path":"/reference/prefilterSAM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"prefilterSAM — prefilterSAM","text":"","code":"# Bootstrapped differential expression based on SAM.   # Parameters: FDR = 0.05, iter = 100, percentage filter = 80 %   # CAUTION: if the data have a high number of genes this function will take several minutes to compute.   data(prefilterSAM)    set.seed(5)   DE_list_genes <- prefilterSAM(mExprs, mPheno$ER.IHC) #> 2025-04-24 12:27:26.488704 #>  Progress: 1/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.882082, all FDRs are smaller than 0.05. #>  Progress: 2/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.767022, all FDRs are smaller than 0.05. #>  Progress: 3/100 #> For Delta >= 0.299952, all FDRs are smaller than 0.05. #>  Progress: 4/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.710353, all FDRs are smaller than 0.05. #>  Progress: 5/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.747871, all FDRs are smaller than 0.05. #>  Progress: 6/100 #> For Delta >= 0.152733, all FDRs are smaller than 0.05. #>  Progress: 7/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 8/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.114115, all FDRs are smaller than 0.05. #>  Progress: 9/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.159556, all FDRs are smaller than 0.05. #>  Progress: 10/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.917052, all FDRs are smaller than 0.05. #>  Progress: 11/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.992159, all FDRs are smaller than 0.05. #>  Progress: 12/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 13/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.57915, all FDRs are smaller than 0.05. #>  Progress: 14/100 #> For Delta >= 0.271571, all FDRs are smaller than 0.05. #>  Progress: 15/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.186251, all FDRs are smaller than 0.05. #>  Progress: 16/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.090498, all FDRs are smaller than 0.05. #>  Progress: 17/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.780918, all FDRs are smaller than 0.05. #>  Progress: 18/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.565798, all FDRs are smaller than 0.05. #>  Progress: 19/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.499581, all FDRs are smaller than 0.05. #>  Progress: 20/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.926352, all FDRs are smaller than 0.05. #>  Progress: 21/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.372193, all FDRs are smaller than 0.05. #>  Progress: 22/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.271911, all FDRs are smaller than 0.05. #>  Progress: 23/100 #> For Delta >= 0.288377, all FDRs are smaller than 0.05. #>  Progress: 24/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 25/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.441612, all FDRs are smaller than 0.05. #>  Progress: 26/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.452891, all FDRs are smaller than 0.05. #>  Progress: 27/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.490172, all FDRs are smaller than 0.05. #>  Progress: 28/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.751042, all FDRs are smaller than 0.05. #>  Progress: 29/100 #> For Delta >= 0.193117, all FDRs are smaller than 0.05. #>  Progress: 30/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.433616, all FDRs are smaller than 0.05. #>  Progress: 31/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.303926, all FDRs are smaller than 0.05. #>  Progress: 32/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 33/100 #> For Delta >= 0.136389, all FDRs are smaller than 0.05. #>  Progress: 34/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 2.220244, all FDRs are smaller than 0.05. #>  Progress: 35/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.634363, all FDRs are smaller than 0.05. #>  Progress: 36/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.430684, all FDRs are smaller than 0.05. #>  Progress: 37/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.197038, all FDRs are smaller than 0.05. #>  Progress: 38/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.84943, all FDRs are smaller than 0.05. #>  Progress: 39/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.456953, all FDRs are smaller than 0.05. #>  Progress: 40/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.620601, all FDRs are smaller than 0.05. #>  Progress: 41/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.745684, all FDRs are smaller than 0.05. #>  Progress: 42/100 #> For Delta >= 0.161207, all FDRs are smaller than 0.05. #>  Progress: 43/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.97555, all FDRs are smaller than 0.05. #>  Progress: 44/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.395494, all FDRs are smaller than 0.05. #>  Progress: 45/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 46/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.865544, all FDRs are smaller than 0.05. #>  Progress: 47/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.695939, all FDRs are smaller than 0.05. #>  Progress: 48/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.329712, all FDRs are smaller than 0.05. #>  Progress: 49/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.155021, all FDRs are smaller than 0.05. #>  Progress: 50/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 51/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.759343, all FDRs are smaller than 0.05. #>  Progress: 52/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.25334, all FDRs are smaller than 0.05. #>  Progress: 53/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.604431, all FDRs are smaller than 0.05. #>  Progress: 54/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.864314, all FDRs are smaller than 0.05. #>  Progress: 55/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 56/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.399625, all FDRs are smaller than 0.05. #>  Progress: 57/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.400041, all FDRs are smaller than 0.05. #>  Progress: 58/100 #> For Delta >= 0.293107, all FDRs are smaller than 0.05. #>  Progress: 59/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.854155, all FDRs are smaller than 0.05. #>  Progress: 60/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.565921, all FDRs are smaller than 0.05. #>  Progress: 61/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.738672, all FDRs are smaller than 0.05. #>  Progress: 62/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.607098, all FDRs are smaller than 0.05. #>  Progress: 63/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.600248, all FDRs are smaller than 0.05. #>  Progress: 64/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.548246, all FDRs are smaller than 0.05. #>  Progress: 65/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.028952, all FDRs are smaller than 0.05. #>  Progress: 66/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.145446, all FDRs are smaller than 0.05. #>  Progress: 67/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.489462, all FDRs are smaller than 0.05. #>  Progress: 68/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 69/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.1332, all FDRs are smaller than 0.05. #>  Progress: 70/100 #> For Delta >= 0.304696, all FDRs are smaller than 0.05. #>  Progress: 71/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.511565, all FDRs are smaller than 0.05. #>  Progress: 72/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.862977, all FDRs are smaller than 0.05. #>  Progress: 73/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.698075, all FDRs are smaller than 0.05. #>  Progress: 74/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.308615, all FDRs are smaller than 0.05. #>  Progress: 75/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.423496, all FDRs are smaller than 0.05. #>  Progress: 76/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.050901, all FDRs are smaller than 0.05. #>  Progress: 77/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.22891, all FDRs are smaller than 0.05. #>  Progress: 78/100 #> For Delta >= 0.387276, all FDRs are smaller than 0.05. #>  Progress: 79/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.110442, all FDRs are smaller than 0.05. #>  Progress: 80/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.339186, all FDRs are smaller than 0.05. #>  Progress: 81/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.662679, all FDRs are smaller than 0.05. #>  Progress: 82/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.000853, all FDRs are smaller than 0.05. #>  Progress: 83/100 #> For Delta >= 0.105715, all FDRs are smaller than 0.05. #>  Progress: 84/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.019102, all FDRs are smaller than 0.05. #>  Progress: 85/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.298774, all FDRs are smaller than 0.05. #>  Progress: 86/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.234585, all FDRs are smaller than 0.05. #>  Progress: 87/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.951315, all FDRs are smaller than 0.05. #>  Progress: 88/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.42788, all FDRs are smaller than 0.05. #>  Progress: 89/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.234133, all FDRs are smaller than 0.05. #>  Progress: 90/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.539187, all FDRs are smaller than 0.05. #>  Progress: 91/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.28385, all FDRs are smaller than 0.05. #>  Progress: 92/100 #> For Delta >= 0.150867, all FDRs are smaller than 0.05. #>  Progress: 93/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.985415, all FDRs are smaller than 0.05. #>  Progress: 94/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.774216, all FDRs are smaller than 0.05. #>  Progress: 95/100 #> For Delta >= 0.466054, all FDRs are smaller than 0.05. #>  Progress: 96/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 0.324306, all FDRs are smaller than 0.05. #>  Progress: 97/100 #> For Delta >= 0.1, all FDRs are smaller than 0.05. #>  Progress: 98/100 #> For Delta >= 0.421601, all FDRs are smaller than 0.05. #>  Progress: 99/100 #> For Delta >= 0.203498, all FDRs are smaller than 0.05. #>  Progress: 100/100 #> Warning: The spline based estimation of pi0 results in a non-positive value of pi0. #> Therefore, pi0 is estimated by using lambda = 0.5. #> For Delta >= 1.217753, all FDRs are smaller than 0.05."}]
